% !TeX spellcheck = fr_FR
\chapter{Chapitre 7 : Base de données et données persistantes}

\section*{Pourquoi un chapitre sur la base de données ?}

Cette application est construite autour d'un \textit{graphe spatial} de points d'arrêt. Le rendu cartographique en temps réel, l'analyse des problèmes et la consolidation des correspondances s'appuient sur un schéma de base de données optimisé pour la lecture, avec une logique d'\textit{ingestion} explicite. Ce chapitre rend cette mécanique visible.

\vspace{0.5em}
Le chapitre \texttt{chap8.tex} plongera ensuite dans le backend (API, endpoints, sécurité, pagination, etc.), en s'appuyant sur les éléments que nous posons ici.


\section{Importer les données: le rôle de \texttt{import\_data\_db.py}}
L'import est orchestré par le script \texttt{import\_data\_db.py}. Il nettoie, croise des sources, calcule des priorités de problèmes, et construit des artefacts prêts pour l'interface.

\subsection*{Vue d'ensemble}
L'import s'exécute en phases clairement découpées (implémentées dans \texttt{import\_to\_database(...)}):
\begin{itemize}
  \item \textbf{Préparer les données de lignes} (\texttt{load\_route\_data}, \texttt{load\_unified\_route\_data}) : charge les informations de lignes GTFS/HRDF par \texttt{sloid} et les routes OSM par \texttt{node\_id}.
  \item \textbf{Construire les correspondances route/direction} (\texttt{build\_route\_direction\_mapping}) : crée les mappings \((\texttt{route\_id}, \texttt{direction\_id}) \leftrightarrow \texttt{osm\_nodes}\) et \((\texttt{route\_id}, \texttt{direction\_id}) \leftrightarrow \texttt{sloids}\), ainsi que \((\texttt{line\_name}, \texttt{direction\_uic}) \leftrightarrow \texttt{sloids}\) pour HRDF.
  \item \textbf{Ingestion des arrêts} : insère les entrées \texttt{matched}, \texttt{unmatched} (ATLAS) et \texttt{osm} (OSM) dans \texttt{stops}, peuple \texttt{atlas\_stops} et \texttt{osm\_nodes}, et détecte les problèmes (\texttt{distance}, \texttt{unmatched}, \texttt{attributes}, \texttt{duplicates}).
  \item \textbf{Consolidation des lignes} : insère les enregistrements \texttt{routes\_and\_directions} pour alimenter filtres et analyses (cas \og matched \fg{}, \og osm\_only \fg{}, \og atlas\_only \fg{}).
  \item \textbf{Ré-application des données persistantes} (\texttt{apply\_persistent\_solutions}) : ré-applique solutions et notes persistantes à la nouvelle importation.
\end{itemize}

L'import crée des \textit{stops} de trois types:\ \texttt{matched} (paires ATLAS–OSM), \texttt{unmatched} (ATLAS isolé), \texttt{osm} (OSM isolé). Ces valeurs de \texttt{stop\_type} sont appliquées par logique métier lors de l'import et peuvent être modifiées via match manuel. Les détails riches (ex: opérateur ATLAS, tags OSM, routes) sont stockés dans des tables dédiées.

Pour la ré-application des données persistantes, le script balaye la table \texttt{persistent\_data} et met à jour les nouveaux enregistrements:

\begin{codebox}[language=Python]{Ré-application des solutions persistantes}
# Extrait de import_data_db.py -> apply_persistent_solutions()
persistent_solutions = session.query(PersistentData)\
    .filter(PersistentData.note_type.is_(None)).all()

for ps in persistent_solutions:
    matching_stops = session.query(Stop)\
        .filter((Stop.sloid == ps.sloid) | (Stop.osm_node_id == ps.osm_node_id))\
        .all()
    
    for stop in matching_stops:
        problem = session.query(Problem).filter(
            Problem.stop_id == stop.id,
            Problem.problem_type == ps.problem_type
        ).first()
        
        if problem:
            problem.solution = ps.solution
            problem.is_persistent = True
\end{codebox}

\section{Schéma logique: les tables qui comptent}

Le schéma applicatif est défini dans \texttt{backend/models.py} et utilise l'ORM SQLAlchemy\citeref{ref:sqlalchemy_docs} pour interagir avec la base de données. Voici les entités principales:

\begin{description}
  \item[\texttt{stops}] Table centrale pour le rendu cartographique. Colonnes clefs: \texttt{sloid}, \texttt{stop\_type}, \texttt{match\_type}, coordonnées (\texttt{atlas\_lat/lon} et \texttt{osm\_lat/lon}), \texttt{distance\_m}, \texttt{osm\_node\_type}, \texttt{atlas\_duplicate\_sloid}.
  
  \item[\texttt{atlas\_stops}] Détails ATLAS par \texttt{sloid}: désignation, opérateur, routes unifiées, notes persistantes.
  
  \item[\texttt{osm\_nodes}] Détails OSM par \texttt{osm\_node\_id}: tags de transport, opérateur, routes OSM, notes.
  
  \item[\texttt{problems}] Détections automatiques (\texttt{distance}, \texttt{unmatched}, \texttt{attributes}, \texttt{duplicates}), solution éventuelle, \texttt{priority} et traçabilité auteur.
  
  \item[\texttt{persistent\_data}] Stockage des solutions et notes destinées à survivre aux ré-imports.
  
  \item[\texttt{routes\_and\_directions}] Consolidation GTFS/HRDF/OSM avec clés multiples: (\texttt{route\_id}, \texttt{direction\_id}) pour GTFS/OSM et (\texttt{line\_name}, \texttt{direction\_uic}) pour HRDF, plus \texttt{route\_id\_normalized} pour unification.
\end{description}

\paragraph{Note sur l'authentification} Un schéma séparé (\texttt{auth\_db}) stocke les utilisateurs (\texttt{users}) et les événements (\texttt{auth\_events}) via un bind SQLAlchemy distinct (\texttt{\_\_bind\_key\_='auth'}). Il est volontairement isolé du schéma métier; nous le détaillons au Chap.~\ref{chap:auth}.

\subsection*{Diagramme conceptuel}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[>=stealth, scale=0.82, transform shape]
    \tikzstyle{tbl}=[draw, rounded corners, minimum width=5cm, minimum height=1.5cm, align=center, fill=gray!5, font=\small]
    \tikzstyle{ghost}=[draw, dashed, rounded corners, minimum width=5cm, minimum height=1.3cm, align=center, font=\small]

    % Utilisation de coordonnées absolues pour un meilleur contrôle
    % Ligne supérieure: atlas_stops - stops - osm_nodes
    \node[tbl] (atlas) at (0,3) {\textbf{atlas\_stops}\\ (sloid PK)};
    \node[tbl] (stops) at (6,3) {\textbf{stops}\\ (id PK; sloid, osm\_node\_id;\\ distance\_m; osm\_node\_type)};
    \node[tbl] (osm) at (12,3) {\textbf{osm\_nodes}\\ (osm\_node\_id PK)};
    
    % Ligne médiane: persistent_data - problems
    \node[ghost] (persist) at (0,0) {\textbf{persistent\_data}\\ (sloid, osm\_node\_id,\\ problem\_type, note\_*)};
    \node[tbl] (problems) at (6,0) {\textbf{problems}\\ (stop\_id FK; problem\_type;\\ priority; solution)};
    
    % Ligne inférieure: routes_and_directions (centré)
    \node[tbl] (routes) at (6,-3) {\textbf{routes\_and\_directions}\\ (route\_id, direction\_id |\\ line\_name, direction\_uic)};

    % Relations avec numéros
    \draw[<->] (atlas) -- node[fill=white, circle, inner sep=2pt]{\small 1} (stops);
    \draw[<->] (stops) -- node[fill=white, circle, inner sep=2pt]{\small 2} (osm);
    \draw[->] (problems) -- node[fill=white, circle, inner sep=2pt]{\small 3} (stops);
    \draw[dashed,->] (persist) -- node[fill=white, circle, inner sep=2pt]{\small 4} (stops);
    \draw[dashed,->] (routes) -- node[fill=white, circle, inner sep=2pt]{\small 5} (atlas);
    \draw[dashed,->] (routes) -- node[fill=white, circle, inner sep=2pt]{\small 6} (osm);

    % Légende des relations
    \node[below of=routes, node distance=2.5cm, align=left, font=\footnotesize] (legend) {
      \textbf{Relations:}\\
      \textbf{1.} atlas\_stops $\leftrightarrow$ stops : jointure via \texttt{sloid}\\
      \textbf{2.} stops $\leftrightarrow$ osm\_nodes : jointure via \texttt{osm\_node\_id}\\
      \textbf{3.} problems $\rightarrow$ stops : clé étrangère \texttt{stop\_id}\\
      \textbf{4.} persistent\_data $\rightarrow$ stops : jointure \texttt{sloid}/\texttt{osm\_node\_id}\\
      \textbf{5.} routes\_and\_directions $\rightarrow$ atlas\_stops : via \texttt{atlas\_sloids\_json}\\
      \textbf{6.} routes\_and\_directions $\rightarrow$ osm\_nodes : via \texttt{osm\_nodes\_json}\\[0.2em]
      \textit{Consolidation GTFS/HRDF/OSM pour filtres UI et analyses}
    };
  \end{tikzpicture}
  \caption[Schéma relationnel des tables]{Schéma relationnel des tables principales (liens via champs de jointure; FK explicite seulement pour \texttt{problems.stop\_id}).}
\end{figure}

\noindent
Remarque: les liens \og stops $\rightarrow$ détails \fg{} sont réalisés par \textit{jointures explicites} (\texttt{sloid}, \texttt{osm\_node\_id}) plutôt que des clés étrangères rigides. Ce choix facilite l'ingestion et limite les verrouillages lors des rafraîchissements, tout en gardant des \textit{indexes} ciblés pour les requêtes critiques. L'ORM SQLAlchemy définit des relations \texttt{lazy='joined'} sur ces champs pour optimiser les accès.

\subsection*{Index utiles pour la carte}
\begin{itemize}
  \item \texttt{idx\_atlas\_lat\_lon} et \texttt{idx\_osm\_lat\_lon} pour filtrer vite par fenêtre cartographique.
  \item \texttt{idx\_stop\_type\_match\_type} pour les filtres dynamiques.
  \item \texttt{idx\_distance\_m} pour les tris par distance.
  \item Sur \texttt{routes\_and\_directions}: \texttt{idx\_osm\_route\_direction}, \texttt{idx\_atlas\_route\_direction}, \texttt{idx\_atlas\_line\_direction\_uic}, et \texttt{idx\_source} (colonne \texttt{source} pour différencier GTFS/HRDF). Le champ \texttt{route\_id\_normalized} sert à l'unification cross-sources.
\end{itemize}


\section{Pros et cons du schéma vis-à-vis du rendu cartographique}
\subsection*{Points forts}
\begin{itemize}
  \item \textbf{Lecture optimisée}: une ligne de \texttt{stops} suffit pour dessiner un marqueur (ATLAS ou OSM) sans \texttt{JOIN}.
  \item \textbf{SARGable viewport}: la requête de fenêtre cartographique est \emph{sélective} grâce aux index lat/lon des deux mondes (extrait d'API ci-dessous).
  \item \textbf{Détails séparés}: les tables \texttt{atlas\_stops} et \texttt{osm\_nodes} chargent les popups à la demande (lazy) sans gonfler la ligne \texttt{stops}.
  \item \textbf{Routes consolidées}: la table \texttt{routes\_and\_directions} alimente les filtres par ligne et direction côté UI.
\end{itemize}

\subsection*{Compromis}
\begin{itemize}
  \item \textbf{Intégrité logique}: l'absence de FK strictes suppose une discipline d'import (gérée par \texttt{import\_data\_db.py}).
  \item \textbf{Duplication contrôlée}: certaines valeurs (ex: \texttt{distance\_m}) sont redondantes par design pour éviter des calculs à la volée.
\end{itemize}

\subsection*{La requête de fenêtre}

\begin{codebox}[language=Python]{Filtrage géographique optimisé — backend/blueprints/data.py}
# Requête SARGable pour l'endpoint /api/data
viewport_sargable = or_(
    # Points ATLAS dans la fenêtre
    and_(Stop.atlas_lat.between(min_lat, max_lat),
         Stop.atlas_lon.between(min_lon, max_lon)),
    
    # Points OSM seuls dans la fenêtre  
    and_(Stop.atlas_lat.is_(None), Stop.atlas_lon.is_(None),
         Stop.osm_lat.between(min_lat, max_lat),
         Stop.osm_lon.between(min_lon, max_lon))
)

query = query.filter(viewport_sargable)
\end{codebox}


\section{Données persistantes: comment elles survivent aux ré-imports}
Le mécanisme de persistance se trouve à deux endroits:\ (i) l'API de gestion (\texttt{/api/make\_solution\_persistent}, \texttt{/api/save\_note/...}),\ (ii) l'étape \texttt{apply\_persistent\_solutions()} de l'import.

La table \texttt{persistent\_data} stocke:
\begin{itemize}
  \item des \textbf{solutions} par triplet \texttt{(sloid, osm\_node\_id, problem\_type)};
  \item des \textbf{notes} persistantes côté ATLAS (\texttt{note\_type = 'atlas'}) ou OSM (\texttt{'osm'}).
\end{itemize}

\subsection*{Côté web (UI)}
Dans l'interface \og Problèmes \fg{}, l'utilisateur peut:
\begin{itemize}
  \item résoudre un problème, puis \textit{rendre la solution persistante} (bouton dédié) ;
  \item saisir une note côté ATLAS ou OSM et la marquer persistante ;
  \item effectuer un \textit{match manuel} entre deux entrées (ATLAS $\leftrightarrow$ OSM) et l'enregistrer de manière durable.
\end{itemize}
On vera la UI en détail et avec captures d'écran dans le chapitre 9.


\section{Essentiels à retenir}

L'expérience utilisateur fluide de la carte interactive repose sur deux principes architecturaux complémentaires: une ligne \texttt{stops} \emph{auto-suffisante} pour dessiner chaque marqueur, et des index spatiaux ciblés exploités par des clauses \texttt{BETWEEN} sur \texttt{atlas\_lat/lon} et \texttt{osm\_lat/lon}, qui rendent la requête de fenêtre (\textit{viewport}) très sélective.

Les informations riches (opérateur, routes, notes) sont chargées \textit{au clic} pour construire les popups, ce qui évite de surcharger la phase de récupération initiale. Ce \textit{chargement différé} maintient de bons temps de réponse même avec des centaines de points.

\begin{itemize}
  \item \textbf{Ligne auto-suffisante pour la carte} : une ligne \texttt{stops} suffit pour dessiner un marqueur (ATLAS ou OSM) $\Rightarrow$ pas de jointure lourde (\texttt{JOIN}) au défilement.
  \item \textbf{Requête de fenêtre sélective (SARGable)} : index \texttt{atlas\_lat/lon} \& \texttt{osm\_lat/lon} $\Rightarrow$ filtrage rapide par boîte englobante (bbox).
  \item \textbf{Détails séparés} : \texttt{atlas\_stops} et \texttt{osm\_nodes} servent les popups à la demande (chargement différé).
  \item \textbf{Persistance durable} : \texttt{persistent\_data} stocke solutions et notes qui \og survivent \fg{} aux ré-imports et sont réappliquées.
  \item \textbf{Séparation de l’authentification} : schéma \texttt{auth\_db} isolé via des \textit{binds} SQLAlchemy (sécurité, gouvernance des droits ; détail au Chap.~\ref{chap:auth}).
\end{itemize}