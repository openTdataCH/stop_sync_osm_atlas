services:
  db:
    image: mysql:8.0
    container_name: bachelor_project_db
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: root #
      MYSQL_DATABASE: stops_db
      MYSQL_USER: stops_user
      MYSQL_PASSWORD: 1234 # Password for stops_user is '1234'
    ports:
      - "3306:3306" # Exposes MySQL to your host machine on port 3306
    volumes:
      - mysql_data:/var/lib/mysql
      # MySQL data persists in the volume; database and user are created via env vars
    healthcheck:
      # Using CMD-SHELL to ensure proper variable expansion for healthcheck
      test: ["CMD-SHELL", "mysqladmin ping -h localhost -u$${MYSQL_USER} -p$${MYSQL_PASSWORD}"]
      interval: 10s
      timeout: 5s
      retries: 2

  app:
    build:
      context: .
      args:
        APP_UID: ${APP_UID:-1000}
        APP_GID: ${APP_GID:-1000}
    container_name: bachelor_project_app
    restart: unless-stopped
    ports:
      - "5001:5001"
    volumes:
      - .:/app # Mounts your project directory into the container for live code changes
      # Mount data directory for persistence
      - ./data:/app/data
    depends_on:
      db:
        condition: service_healthy # Waits for db to be healthy before starting app
    environment:
      # Pass MySQL credentials to the entrypoint script and Python apps
      MYSQL_USER: ${MYSQL_USER:-stops_user}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD:-1234} # Ensure this matches db service password
      MYSQL_ROOT_PASSWORD: root # Needed for entrypoint.sh to create auth_db
      # Optional dedicated auth DB user (best practice for least privilege)
      AUTH_DB_USER: ${AUTH_DB_USER:-}
      AUTH_DB_PASSWORD: ${AUTH_DB_PASSWORD:-}
      # Flask environment variables (some are also in Dockerfile for explicitness)
      FLASK_APP: backend/app.py
      FLASK_ENV: development # Or production
      FLASK_DEBUG: 1 # Enables Flask debugger
      # Database URI for SQLAlchemy, now configurable via .env
      DATABASE_URI: ${DATABASE_URI:-mysql+pymysql://stops_user:1234@db/stops_db}
      AUTH_DATABASE_URI: ${AUTH_DATABASE_URI:-mysql+pymysql://stops_user:1234@db/auth_db}
      SECRET_KEY: ${SECRET_KEY:-dev-insecure}
      FORCE_HTTPS: "false"
      SESSION_COOKIE_SECURE: "false"
      AUTO_MIGRATE: "true"
      # Data processing control flags
      MATCH_ONLY: "${MATCH_ONLY:-false}" # Use host env or default to false; set MATCH_ONLY=true to skip downloads
      # Email/SES configuration
      APP_NAME: "OSM-ATLAS Sync"
      SUPPORT_EMAIL: "support@example.com" # optional, shown in email footer
      AWS_REGION: "eu-west-1" # set to your SES region
      SES_FROM_EMAIL: "no-reply@example.com" # must be a verified SES identity
      # Turnstile (optional; if unset, verification is skipped)
      TURNSTILE_SITE_KEY: "${TURNSTILE_SITE_KEY:-}"
      TURNSTILE_SECRET_KEY: "${TURNSTILE_SECRET_KEY:-}"
      # Optional SES configuration set for deliverability tracking
      # SES_CONFIGURATION_SET: "your-config-set"
      # AWS credentials are picked up automatically by the AWS SDK (boto3)
      # You can export AWS_ACCESS_KEY_ID / AWS_SECRET_ACCESS_KEY in your shell
      # or add them here if you prefer (not recommended to commit secrets):
      # AWS_ACCESS_KEY_ID: "..."
      # AWS_SECRET_ACCESS_KEY: "..."
    cpu_shares: 2048 # Higher CPU priority during contention
    mem_limit: 4g # Increase to avoid OOM issues
    # mem_reservation: 1g # Optional: guarantee 1g

  app-dev: # New service for development, skips data import
    profiles:
      - dev
    build:
      context: .
      args:
        APP_UID: ${APP_UID:-1000}
        APP_GID: ${APP_GID:-1000}
    container_name: bachelor_project_app_dev
    restart: unless-stopped
    ports:
      - "5001:5001"
    volumes:
      - .:/app # Mounts your project directory into the container for live code changes
      # Mount data directory for persistence
      - ./data:/app/data
    depends_on:
      db:
        condition: service_healthy # Waits for db to be healthy before starting app
    environment:
      # Pass MySQL credentials to the entrypoint script and Python apps
      MYSQL_USER: ${MYSQL_USER:-stops_user}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD:-1234} # Ensure this matches db service password
      MYSQL_ROOT_PASSWORD: root # Needed for entrypoint.sh to create auth_db
      # Optional dedicated auth DB user (best practice for least privilege)
      AUTH_DB_USER: ${AUTH_DB_USER:-}
      AUTH_DB_PASSWORD: ${AUTH_DB_PASSWORD:-}
      # Flask environment variables (some are also in Dockerfile for explicitness)
      FLASK_APP: backend/app.py
      FLASK_ENV: development # Or production
      FLASK_DEBUG: 1 # Enables Flask debugger
      # Database URI for SQLAlchemy, now configurable via .env
      DATABASE_URI: ${DATABASE_URI:-mysql+pymysql://stops_user:1234@db/stops_db}
      AUTH_DATABASE_URI: ${AUTH_DATABASE_URI:-mysql+pymysql://stops_user:1234@db/auth_db}
      SKIP_DATA_IMPORT: "true" # Skip data import for this service
      SECRET_KEY: ${SECRET_KEY:-dev-insecure}
      FORCE_HTTPS: "false"
      SESSION_COOKIE_SECURE: "false"
      # Auto-generate and apply migrations in dev
      AUTO_MIGRATE: "true"
      # Email/SES configuration (dev)
      APP_NAME: "OSM-ATLAS Sync"
      SUPPORT_EMAIL: "support@example.com"
      AWS_REGION: "eu-west-1"
      SES_FROM_EMAIL: "no-reply@example.com"
      # Turnstile (optional; if unset, verification is skipped)
      TURNSTILE_SITE_KEY: "${TURNSTILE_SITE_KEY:-}"
      TURNSTILE_SECRET_KEY: "${TURNSTILE_SECRET_KEY:-}"
      # SES_CONFIGURATION_SET: "your-config-set"
      # AWS_ACCESS_KEY_ID: "..."
      # AWS_SECRET_ACCESS_KEY: "..."
    cpu_shares: 2048 # Higher CPU priority during contention
    mem_limit: 4g # Increase to avoid OOM issues
    # mem_reservation: 1g # Optional: guarantee 1g

volumes:
  mysql_data: # Persists MySQL data